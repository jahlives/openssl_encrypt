#!/usr/bin/env python3
"""
Launcher script for OpenSSL Encrypt Flatpak package.
Handles both CLI and GUI modes based on command line arguments.
"""

import os
import sys

# Force set environment variables at the very start
os.environ["DISPLAY"] = ":0"
os.environ["XAUTHORITY"] = "/run/user/1000/xauth_PaSUjl"

# Add the application directory to Python path
app_dir = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, app_dir)


def main():
    """Main launcher function."""
    # Check for specific GUI mode requests
    gui_mode = None
    force_tkinter = False
    
    if len(sys.argv) > 1:
        if "--gui-tk" in sys.argv:
            gui_mode = "tkinter"
            force_tkinter = True
            # Remove --gui-tk from arguments to avoid conflicts
            sys.argv = [arg for arg in sys.argv if arg != "--gui-tk"]
        elif "--gui" in sys.argv:
            gui_mode = "auto"
            # Remove --gui from arguments to avoid conflicts
            sys.argv = [arg for arg in sys.argv if arg != "--gui"]
    
    if gui_mode:
        # Determine which GUI to use
        flutter_gui_path = "/app/bin/openssl-encrypt-gui/openssl_encrypt_mobile"
        use_flutter_gui = not force_tkinter and os.path.exists(flutter_gui_path)
        
        if use_flutter_gui:
            # Launch Flutter GUI
            print("üöÄ Launching Flutter desktop GUI...")
            try:
                import subprocess
                # Run the Flutter executable directly
                result = subprocess.run([flutter_gui_path], 
                                      env=os.environ.copy())
                sys.exit(result.returncode)
            except Exception as e:
                print(f"‚ùå Flutter GUI launch failed: {e}", file=sys.stderr)
                print("üîÑ Falling back to tkinter GUI...", file=sys.stderr)
                # Fall through to tkinter GUI
        
        # Launch tkinter GUI (explicit request, fallback, or when Flutter not available)
        if force_tkinter:
            print("üéØ Launching tkinter GUI (explicitly requested)...")
        elif not use_flutter_gui and gui_mode == "auto":
            print("üîÑ Launching tkinter GUI (Flutter not available)...")
        try:
            # Check display environment

            print(f"DISPLAY environment: {os.environ.get('DISPLAY', 'NOT SET')}")
            print(f"WAYLAND_DISPLAY environment: {os.environ.get('WAYLAND_DISPLAY', 'NOT SET')}")
            print(f"XAUTHORITY environment: {os.environ.get('XAUTHORITY', 'NOT SET')}")
            print(
                f"Available display vars: {sorted([k for k in os.environ.keys() if 'DISPLAY' in k.upper() or 'WAYLAND' in k.upper() or 'AUTH' in k.upper()])}"
            )
            print(f"X11 socket exists: {os.path.exists('/tmp/.X11-unix/X0')}")

            # Try to force set environment from command line args
            for arg in sys.argv:
                if arg.startswith("--env=DISPLAY="):
                    display_val = arg.split("=", 2)[2]
                    os.environ["DISPLAY"] = display_val
                    print(f"Set DISPLAY from command line: {display_val}")
                    break

            # First check if tkinter is available
            import tkinter

            print("‚úì tkinter is available")

            # Handle Wayland vs X11 display setup
            wayland_display = os.environ.get("WAYLAND_DISPLAY")
            x11_display = os.environ.get("DISPLAY")

            if wayland_display:
                # Wayland environment - properly configure for XWayland/tkinter compatibility
                print(f"Detected Wayland environment: {wayland_display}")
                os.environ["GDK_BACKEND"] = "wayland,x11"
                
                # For Wayland+XWayland, we need to clear problematic X11 auth
                # and let the system handle authentication automatically
                if "XAUTHORITY" in os.environ:
                    del os.environ["XAUTHORITY"]
                
                # Try to find the correct XWayland display
                current_display = os.environ.get("DISPLAY", ":0")
                print(f"Current DISPLAY setting: {current_display}")
                
                # Check if current display socket exists, if not find an alternative
                current_socket = f"/tmp/.X11-unix/X{current_display[1:] if current_display.startswith(':') else current_display}"
                if os.path.exists(current_socket):
                    print(f"‚úì Display socket exists: {current_socket}")
                else:
                    print(f"‚ö†Ô∏è Display socket not found: {current_socket}")
                    # Try to find an alternative XWayland display
                    found_alternative = False
                    for display_num in [":0", ":1", ":2"]:
                        socket_path = f"/tmp/.X11-unix/X{display_num[1:]}"
                        if os.path.exists(socket_path):
                            os.environ["DISPLAY"] = display_num
                            print(f"Found alternative XWayland display: {display_num}")
                            found_alternative = True
                            break
                    
                    if not found_alternative:
                        print("No XWayland sockets detected, keeping current DISPLAY")
                
                # Additional Wayland compatibility settings
                os.environ["XDG_SESSION_TYPE"] = "wayland"
                os.environ["QT_QPA_PLATFORM"] = "wayland"
                    
                print("Using Wayland with XWayland fallback (automatic auth)")
            elif x11_display:
                print(f"Using X11 display: {x11_display}")
                os.environ["GDK_BACKEND"] = "x11"
                # Keep existing X11 auth for pure X11 environments
            else:
                # No display detected - try Wayland first, then X11
                print("WARNING: No display server detected")
                print("Attempting automatic display detection...")
                os.environ["GDK_BACKEND"] = "wayland,x11"
                
                # Try to detect and set display automatically
                if not os.environ.get("DISPLAY"):
                    os.environ["DISPLAY"] = ":0"

            print(f"Final DISPLAY: {os.environ.get('DISPLAY')}")
            print(f"Final XAUTHORITY: {os.environ.get('XAUTHORITY')}")
            print(f"Final GDK_BACKEND: {os.environ.get('GDK_BACKEND')}")

            # For Flatpak + Wayland, add additional environment variables
            if wayland_display:
                # Force toolkit backends for better Wayland compatibility
                os.environ["ELECTRON_OZONE_PLATFORM_HINT"] = "wayland"
                os.environ["MOZ_ENABLE_WAYLAND"] = "1"
                # Disable problematic X11 features that cause auth issues
                os.environ["NO_AT_BRIDGE"] = "1"
                
            # Test display connection with better error handling
            print("Testing display connection...")
            display_test_passed = False
            try:
                test_root = tkinter.Tk()
                test_root.withdraw()
                test_root.destroy()
                print("‚úì Display connection successful")
                display_test_passed = True
            except Exception as e:
                print(f"‚ö†Ô∏è Display connection test failed: {e}")
                
                # Try alternative approaches for Wayland
                error_str = str(e)
                if wayland_display and ("Authorization required" in error_str or "couldn't connect to display" in error_str):
                    print("‚ö†Ô∏è Trying alternative Wayland configuration...")
                    
                    # Try removing all X11 environment variables
                    x11_vars_to_clear = ["DISPLAY", "XAUTHORITY", "XDISPLAY"]
                    for var in x11_vars_to_clear:
                        if var in os.environ:
                            del os.environ[var]
                    
                    # Try with no DISPLAY set - let tkinter auto-detect
                    print("‚ö†Ô∏è Attempting tkinter with no DISPLAY (auto-detection)...")
                    try:
                        test_root2 = tkinter.Tk()
                        test_root2.withdraw() 
                        test_root2.destroy()
                        print("‚úì Alternative display connection successful!")
                        display_test_passed = True
                    except Exception as e2:
                        print(f"‚ö†Ô∏è Alternative approach also failed: {e2}")
                        
                        # Try one more approach - use Xvfb virtual framebuffer
                        print("‚ö†Ô∏è Attempting to start virtual display (Xvfb)...")
                        try:
                            import subprocess
                            import time
                            
                            # Try to start Xvfb on display :99
                            xvfb_process = subprocess.Popen(['Xvfb', ':99', '-screen', '0', '1024x768x24'], 
                                                          stdout=subprocess.DEVNULL, 
                                                          stderr=subprocess.DEVNULL)
                            time.sleep(1)  # Give Xvfb time to start
                            
                            os.environ["DISPLAY"] = ":99"
                            
                            # Test the virtual display
                            test_root3 = tkinter.Tk()
                            test_root3.withdraw()
                            test_root3.destroy()
                            print("‚úì Virtual display connection successful!")
                            display_test_passed = True
                        except Exception as e3:
                            print(f"‚ö†Ô∏è Virtual display also failed: {e3}")
                            # Restore DISPLAY for the actual GUI attempt
                            os.environ["DISPLAY"] = ":0"
                
                if not display_test_passed:
                    if wayland_display:
                        print("‚ö†Ô∏è This is expected in some Wayland+Flatpak configurations")
                        print("‚ö†Ô∏è Proceeding anyway - tkinter may still work...")
                    else:
                        print("‚ö†Ô∏è X11 connection failed, this may cause issues")
                # Don't fail here - let the actual GUI startup handle the connection

            # Then try to import the GUI module
            from openssl_encrypt.crypt_gui import main as gui_main

            print("‚úì GUI module imported successfully")

            # Font configuration will be handled by the GUI itself
            gui_main()
        except ImportError as e:
            print(f"‚ùå Error: GUI components not available - {e}", file=sys.stderr)
            print("Python path:", sys.path, file=sys.stderr)

            # Try to give more specific error information
            try:
                import tkinter
                print("‚úì tkinter is available, issue is with openssl_encrypt module", file=sys.stderr)
            except ImportError:
                print("‚úó tkinter is not available", file=sys.stderr)

            # If --gui-tk was explicitly requested and failed, try Flutter fallback
            if force_tkinter and os.path.exists(flutter_gui_path):
                print("üîÑ tkinter GUI failed, attempting Flutter GUI fallback...", file=sys.stderr)
                try:
                    import subprocess
                    result = subprocess.run([flutter_gui_path], env=os.environ.copy())
                    sys.exit(result.returncode)
                except Exception as flutter_error:
                    print(f"‚ùå Flutter GUI fallback also failed: {flutter_error}", file=sys.stderr)
            
            sys.exit(1)
        except Exception as e:
            error_msg = str(e)
            print(f"‚ùå Error launching tkinter GUI: {error_msg}", file=sys.stderr)
            
            # Provide specific help for common issues
            if "couldn't connect to display" in error_msg or "Authorization required" in error_msg:
                print("", file=sys.stderr)
                print("üîç Display connection troubleshooting:", file=sys.stderr)
                if wayland_display:
                    print("  ‚Ä¢ Wayland detected - tkinter requires XWayland compatibility", file=sys.stderr)
                    print("  ‚Ä¢ Try: sudo apt install xwayland (on Debian/Ubuntu)", file=sys.stderr)
                    print("  ‚Ä¢ Or install your distribution's XWayland package", file=sys.stderr)
                else:
                    print("  ‚Ä¢ X11 authorization failed - check display permissions", file=sys.stderr)
                    print("  ‚Ä¢ Try: xhost +local: (to allow local connections)", file=sys.stderr)
                print("  ‚Ä¢ Alternative: Use Flutter GUI with --gui command", file=sys.stderr)
                print("", file=sys.stderr)
            
            # If --gui-tk was explicitly requested and failed, try Flutter fallback
            if force_tkinter and os.path.exists(flutter_gui_path):
                print("üîÑ tkinter GUI failed, attempting Flutter GUI fallback...", file=sys.stderr)
                try:
                    import subprocess
                    result = subprocess.run([flutter_gui_path], env=os.environ.copy())
                    sys.exit(result.returncode)
                except Exception as flutter_error:
                    print(f"‚ùå Flutter GUI fallback also failed: {flutter_error}", file=sys.stderr)
            
            sys.exit(1)
    else:
        # Launch CLI
        try:
            from openssl_encrypt.cli import main as cli_main

            cli_main()
        except ImportError:
            print("Error: CLI components not available", file=sys.stderr)
            sys.exit(1)


if __name__ == "__main__":
    main()
