# GitLab CI Pipeline for Docker Container Building
# This file builds production-ready Docker containers with full PQC support

stages:
  - docker-build
  - docker-test
  - docker-publish

variables:
  # Docker registry configuration
  DOCKER_REGISTRY: $CI_REGISTRY
  DOCKER_IMAGE_NAME: $CI_REGISTRY_IMAGE/openssl-encrypt
  DOCKER_IMAGE_TAG: $CI_COMMIT_REF_SLUG
  DOCKER_LATEST_TAG: $CI_REGISTRY_IMAGE/openssl-encrypt:latest
  DOCKER_STABLE_TAG: $CI_REGISTRY_IMAGE/openssl-encrypt:stable
  
  # Docker build optimization
  DOCKER_BUILDKIT: 1
  BUILDX_NO_DEFAULT_ATTESTATIONS: 1
  
  # Build context
  DOCKERFILE_PATH: docker/Dockerfile
  BUILD_CONTEXT: .

# Build the Docker image with full PQC support
docker-build:
  stage: docker-build
  image: docker:24-dind
  services:
    - name: docker:24-dind
      alias: docker
      command: ["--experimental"]
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    # Wait for Docker daemon to be ready
    - until docker info; do sleep 1; done
    # Log in to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Enable Docker BuildKit for better caching and multi-stage builds
    - export DOCKER_BUILDKIT=1
  script:
    # Build the Docker image with BuildKit for optimization
    - |
      docker build \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        --cache-from $DOCKER_IMAGE_NAME:cache \
        --cache-from $DOCKER_LATEST_TAG \
        -f $DOCKERFILE_PATH \
        -t $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA \
        -t $DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG \
        $BUILD_CONTEXT
    # Tag as latest for main/release branches
    - |
      if [[ "$CI_COMMIT_BRANCH" == "main" || "$CI_COMMIT_BRANCH" == "release" || "$CI_COMMIT_TAG" ]]; then
        docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_LATEST_TAG
      fi
    # Tag as stable for release tags
    - |
      if [[ "$CI_COMMIT_TAG" ]]; then
        docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_STABLE_TAG
        docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_IMAGE_NAME:$CI_COMMIT_TAG
      fi
    # Push all tags
    - docker push $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA
    - docker push $DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG
    - |
      if [[ "$CI_COMMIT_BRANCH" == "main" || "$CI_COMMIT_BRANCH" == "release" || "$CI_COMMIT_TAG" ]]; then
        docker push $DOCKER_LATEST_TAG
      fi
    - |
      if [[ "$CI_COMMIT_TAG" ]]; then
        docker push $DOCKER_STABLE_TAG
        docker push $DOCKER_IMAGE_NAME:$CI_COMMIT_TAG
      fi
    # Create cache layer for future builds
    - docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_IMAGE_NAME:cache
    - docker push $DOCKER_IMAGE_NAME:cache || true  # Don't fail if cache push fails
  artifacts:
    reports:
      dotenv: docker-build.env
    expire_in: 1 hour
  after_script:
    # Save build information for subsequent jobs
    - echo "DOCKER_IMAGE_SHA=$DOCKER_IMAGE_NAME:$CI_COMMIT_SHA" >> docker-build.env
    - echo "DOCKER_IMAGE_BUILT=true" >> docker-build.env
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "release"  
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_TAG
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  # Retry on infrastructure failures
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# Test the built Docker image functionality
docker-test:
  stage: docker-test
  image: docker:24-dind
  services:
    - name: docker:24-dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  needs:
    - job: docker-build
      artifacts: true
  before_script:
    # Wait for Docker daemon and login
    - until docker info; do sleep 1; done
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    # Pull the built image
    - docker pull $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA
  script:
    # Test basic functionality
    - echo "Testing basic CLI functionality..."
    - docker run --rm $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA --help
    
    # Test PQC support
    - echo "Testing PQC algorithm listing..."
    - |
      docker run --rm $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA encrypt --help | \
      grep -E "(kyber|ml-kem|hqc)" || (echo "PQC algorithms not found in help" && exit 1)
    
    # Test actual encryption/decryption with PQC
    - echo "Testing PQC encryption/decryption..."
    - mkdir -p test-data
    - echo "Hello PQC World from GitLab CI!" > test-data/test.txt
    - |
      docker run --rm -v $(pwd)/test-data:/data $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA \
      encrypt --input test.txt --algorithm kyber768-hybrid --password "TestPassword123!" --force-password --overwrite
    
    # Verify encrypted file was created and has content
    - test -f test-data/test.txt
    - test -s test-data/test.txt
    - echo "✅ Docker image tests passed!"
    
    # Test version information
    - echo "Testing version information..."
    - docker run --rm $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA version || true
    
    # Test PQC library availability
    - echo "Testing PQC library availability..."
    - |
      docker run --rm --entrypoint="" $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA \
      python -c "
      from openssl_encrypt.modules.pqc_liboqs import check_liboqs_support
      available, version, algorithms = check_liboqs_support(quiet=True)
      print(f'PQC Available: {available}')
      print(f'Algorithms: {len(algorithms)}')
      assert available, 'PQC support not available'
      assert len(algorithms) > 50, f'Too few algorithms: {len(algorithms)}'
      print('✅ PQC tests passed!')
      "
  artifacts:
    paths:
      - test-data/
    expire_in: 1 hour
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "release"
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_TAG
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Publish Docker images to registry (for release branches/tags)
docker-publish:
  stage: docker-publish
  image: docker:24-dind
  services:
    - name: docker:24-dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  needs:
    - job: docker-build
      artifacts: true
    - job: docker-test
  before_script:
    - until docker info; do sleep 1; done
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # Pull the tested image
    - docker pull $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA
    
    # Create and push release tags
    - |
      if [[ "$CI_COMMIT_TAG" ]]; then
        echo "Publishing release tag: $CI_COMMIT_TAG"
        docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_IMAGE_NAME:$CI_COMMIT_TAG
        docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_STABLE_TAG
        docker push $DOCKER_IMAGE_NAME:$CI_COMMIT_TAG
        docker push $DOCKER_STABLE_TAG
        echo "✅ Published release images"
      fi
    
    # Update latest tag for main branch
    - |
      if [[ "$CI_COMMIT_BRANCH" == "main" ]]; then
        echo "Updating latest tag for main branch"
        docker tag $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA $DOCKER_LATEST_TAG
        docker push $DOCKER_LATEST_TAG
        echo "✅ Updated latest tag"
      fi
    
    # Generate image information
    - echo "=== Docker Image Information ==="
    - echo "Registry: $CI_REGISTRY"
    - echo "Image: $DOCKER_IMAGE_NAME"
    - echo "Tags available:"
    - echo "  - $DOCKER_IMAGE_NAME:$CI_COMMIT_SHA"
    - echo "  - $DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG"
    - |
      if [[ "$CI_COMMIT_TAG" ]]; then
        echo "  - $DOCKER_IMAGE_NAME:$CI_COMMIT_TAG"
        echo "  - $DOCKER_STABLE_TAG"
      fi
    - |
      if [[ "$CI_COMMIT_BRANCH" == "main" || "$CI_COMMIT_BRANCH" == "release" ]]; then
        echo "  - $DOCKER_LATEST_TAG"
      fi
    
    # Display usage instructions
    - echo ""
    - echo "=== Usage Instructions ==="
    - echo "Pull and run the image:"
    - echo "  docker pull $DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG"
    - echo "  docker run --rm -v \$(pwd):/data $DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG --help"
    - echo ""
    - echo "Encrypt a file with PQC:"
    - echo "  docker run --rm -v \$(pwd):/data $DOCKER_IMAGE_NAME:$DOCKER_IMAGE_TAG \\"
    - echo "    encrypt --input myfile.txt --algorithm kyber768-hybrid --password 'YourPassword'"
    
  rules:
    - if: $CI_COMMIT_TAG
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "release"
      when: manual
      allow_failure: false

# Manual job to rebuild Docker image (for dev/testing)
docker-rebuild:
  extends: docker-build
  when: manual
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "testing"

# Clean up old Docker images (manual job)
docker-cleanup:
  stage: docker-publish
  image: docker:24-dind
  services:
    - name: docker:24-dind
      alias: docker
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    DOCKER_TLS_VERIFY: 1
    DOCKER_CERT_PATH: "$DOCKER_TLS_CERTDIR/client"
  before_script:
    - until docker info; do sleep 1; done
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # Clean up old/unused images to save space
    - docker system prune -af || true
    - echo "✅ Docker cleanup completed"
  when: manual
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "dev"