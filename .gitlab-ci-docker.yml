# GitLab CI configuration for building Docker base images
# This file contains jobs for building the python-liboqs base image used by the main CI pipeline

stages:
  - docker-build

variables:
  # Override these variables if needed
  DOCKER_IMAGE: $CI_REGISTRY_IMAGE/python-liboqs:3.13-alpine
  LIBOQS_VERSION: "0.12.0"
  PYTHON_VERSION: "3.13"

# Build the python-liboqs base image for testing
# This job builds Python 3.13 Alpine with liboqs pre-installed for faster CI testing
docker-build-base:
  stage: docker-build
  image: docker:24-cli
  services:
    - name: docker:24-dind
      alias: docker
      command: ["--tls=false"]
  variables:
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    DOCKER_DRIVER: overlay2
    DOCKER_BUILDKIT: 1
  before_script:
    # Wait for Docker daemon to be ready
    - until docker info; do sleep 1; done
    # Login to GitLab Container Registry
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - |
      # Create Dockerfile for python-liboqs base image
      cat > Dockerfile.base << EOF
      FROM python:${PYTHON_VERSION}-alpine
      
      # Install build dependencies for liboqs (Alpine Linux packages)
      RUN apk add --no-cache \\
          git gcc g++ cmake ninja make go \\
          python3-dev openssl-dev musl-dev \\
          linux-headers
      
      # Clone and build liboqs
      WORKDIR /build
      RUN git clone --recurse-submodules --branch ${LIBOQS_VERSION} https://github.com/open-quantum-safe/liboqs.git
      WORKDIR /build/liboqs
      RUN mkdir build && cd build && \\
          cmake -GNinja -DCMAKE_INSTALL_PREFIX=/usr/local .. && \\
          ninja && \\
          ninja install
      
      # Install Python liboqs bindings
      RUN pip install --no-cache-dir git+https://github.com/open-quantum-safe/liboqs-python.git@${LIBOQS_VERSION}
      
      # Clean up build artifacts but keep runtime libraries
      RUN apk del git gcc g++ cmake ninja make go && \\
          rm -rf /build /var/cache/apk/*
      
      # Update library cache
      RUN ldconfig /usr/local/lib
      
      # Verify liboqs installation
      RUN python -c "import oqs; print(f'liboqs version: {oqs.oqs_version()}')" && \\
          python -c "import oqs; print(f'Available KEMs: {len(oqs.get_enabled_KEM_mechanisms())}')"
      
      # Add build metadata
      LABEL org.opencontainers.image.title="Python liboqs Base Image"
      LABEL org.opencontainers.image.description="Python ${PYTHON_VERSION} Alpine with liboqs ${LIBOQS_VERSION} for PQC testing"
      LABEL org.opencontainers.image.version="${LIBOQS_VERSION}"
      LABEL org.opencontainers.image.created="$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
      LABEL org.opencontainers.image.source="${CI_PROJECT_URL}"
      LABEL org.opencontainers.image.revision="${CI_COMMIT_SHA}"
      
      WORKDIR /
      EOF
    
    # Build the base image
    - echo "Building base image with Python ${PYTHON_VERSION} and liboqs ${LIBOQS_VERSION}..."
    - docker build -f Dockerfile.base -t $DOCKER_IMAGE .
    
    # Tag with additional version tags
    - docker tag $DOCKER_IMAGE $DOCKER_IMAGE:latest
    - docker tag $DOCKER_IMAGE $DOCKER_IMAGE:python${PYTHON_VERSION}-liboqs${LIBOQS_VERSION}
    - docker tag $DOCKER_IMAGE $DOCKER_IMAGE:$(date +%Y%m%d)
    
    # Push all tags to registry
    - docker push $DOCKER_IMAGE
    - docker push $DOCKER_IMAGE:latest  
    - docker push $DOCKER_IMAGE:python${PYTHON_VERSION}-liboqs${LIBOQS_VERSION}
    - docker push $DOCKER_IMAGE:$(date +%Y%m%d)
    
    # Display build info
    - echo "=== Docker Image Build Summary ==="
    - docker images $DOCKER_IMAGE*
    - docker inspect $DOCKER_IMAGE --format='{{.Config.Labels}}'
    - echo "Base image built and pushed successfully!"
    - echo "Available tags:"
    - echo "  - $DOCKER_IMAGE (default)"
    - echo "  - $DOCKER_IMAGE:latest"
    - echo "  - $DOCKER_IMAGE:python${PYTHON_VERSION}-liboqs${LIBOQS_VERSION}"
    - echo "  - $DOCKER_IMAGE:$(date +%Y%m%d)"
  rules:
    # Run on scheduled pipelines (nightly builds) 
    - if: $CI_PIPELINE_SOURCE == "schedule" && $CI_COMMIT_BRANCH == "dev"
    # Manual trigger for rebuilding base image
    - if: $CI_COMMIT_BRANCH == "dev"
      when: manual
      allow_failure: false
    # Run on main branch for releases
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: false
  artifacts:
    reports:
      # Export build metadata for other jobs
      dotenv: build.env
    paths:
      - Dockerfile.base
    expire_in: 1 day
  after_script:
    # Create build environment file for downstream jobs
    - echo "DOCKER_BASE_IMAGE_BUILT=true" >> build.env
    - echo "DOCKER_BASE_IMAGE_TAG=$DOCKER_IMAGE" >> build.env
    - echo "BUILD_DATE=$(date +%Y%m%d)" >> build.env

# Test the built base image
docker-test-base:
  stage: docker-build
  image: $DOCKER_IMAGE
  needs:
    - job: docker-build-base
      artifacts: true
  variables:
    PQC_QUIET: "true"
  script:
    - echo "=== Testing Python liboqs Base Image ==="
    - python --version
    - echo "Testing liboqs availability..."
    - python -c "import oqs; print(f'✓ liboqs version: {oqs.oqs_version()}')"
    - python -c "import oqs; print(f'✓ Available KEMs: {len(oqs.get_enabled_KEM_mechanisms())}')"
    - python -c "import oqs; print(f'✓ Available Signatures: {len(oqs.get_enabled_sig_mechanisms())}')"
    - echo "Testing basic KEM operations..."
    - python -c "
import oqs
kem = oqs.KeyEncapsulation('Kyber512')
public_key, secret_key = kem.generate_keypair()
ciphertext, shared_secret = kem.encap(public_key) 
decrypted_secret = kem.decap(secret_key, ciphertext)
assert shared_secret == decrypted_secret
print('✓ Basic KEM test passed')
"
    - echo "=== Base image test completed successfully! ==="
  rules:
    # Test after successful build
    - if: $CI_PIPELINE_SOURCE == "schedule" && $CI_COMMIT_BRANCH == "dev"
    - if: $CI_COMMIT_BRANCH == "dev"
      when: manual
    - if: $CI_COMMIT_BRANCH == "main"  
      when: manual